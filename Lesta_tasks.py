# ---------------------------------------------
# Задание 1
# ---------------------------------------------


# первая функция использует логический оператор И(&) который проверяет последнюю цифру в двоичной записи числа
# так как у чётных чисел в двоичной записи на конце всегда будет ноль (0,10,100,110,1000) и так далее, если логическое И
# ложное, оно выведет чётное число. Данный способ значительно быстрее чем просто отстаток от деления,
# указанный в примере, так как логическое И проверяет только последнюю цифру в двоичной записи
# в отличии от деления, что значительно дольше по выполнению

def even_1(n):
    for x in range(n):
        if not x & 1:
            print(x)


print(even_1(5))


# Второй способ преобразует число в строку и если на его конце есть 0, 2, 4, 6, 8 то есть чётное число, то тем самым
# функция введет чётное число, однако эта реализация значительно хуже чем функция выше и функция в примере, однако
# стоит принять во внимание, что такая реализация возможна. Из-за нескольких преобразований, содания списка она будет
# выполняться сильно дольше чем остальные


def even_2(k):
    for i in range(k):
        if str(i)[-1] in ['0', '2', '4', '6', '8']:
            print(i)


print(even_2(5))

# ---------------------------------------------
# Задание 2
# ---------------------------------------------

# Первая реализация
# В данной реализации класса нету наследования от класса list, благодаря чему можно указать конкретные методы,
# которые нужны для создания циклического буфера FIFO, в случае с этим классом создаётся сам список в конструкторе
# метод класса len для контроля размера списка, эта реализация имеет плюс в том, что можно создать все методы под
# конкретное задание и не перегружать его наследованием, однако придётся реализовать каждый метод вручную


class Queue_1:
    def __init__(self, *args):
        self.items = list(args)

    def __len__(self):
        return len(self.items)

    def get(self):
        return self.items.pop(0)

    def put(self, item):
        self.items.append(item)


r = Queue_1()

for i in range(5):
    r.put(i)

while len(r):
    print(r.get(), end=' ')

# Во второй реализации класса используется наследование от класса list что позволяет использовать его функционал
# и не прописывать методы вручную, это плюс, так как можно не задумываться о том, какие методы класса лист нам нужны
# они все наследуются от родительсткого класса и доступны с самого начала, из минусов стоит отвметить увеличесние
# времени исполнения программы


class Queue_2(list):

    def get(self):
        return self.pop(0)

    def put(self, item):
        self.append(item)


q = Queue_2()

for i in range(5):
    q.put(i)

while len(q):
    print(q.get(), end=' ')

# ---------------------------------------------
# Задание 3
# ---------------------------------------------

# в данном задании выбранна быстрая сортировка
# алгоритм быстрой сортировки имеет скорость О(nlog(n)) в среднем, что делает его по скорости значительно быстрее
# чем пузырьковая сортировка, сортировка слиянием, вставками и выбором и как следствие является самым стабильным из них


def quick_sort(s):
    if len(s) <= 1:
        return s
    elem = s[0]
    left = list(filter(lambda x: x < elem, s))
    center = [i for i in s if i == elem]
    right = list(filter(lambda x: x > elem, s))

    return quick_sort(left) + center + quick_sort(right)


print(quick_sort([10, 9, 8, 7, 6, 5, 2, 4, 1, 3]))

